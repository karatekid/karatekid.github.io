---
layout: post
title: Making a Digital Oscilloscope UI
---

I previously [setup a way for C / C++ programs to communicate to a JS
client using Thrift]({% post_url 2015-3-2-making-a-simple-ui-for-c-programs %}). Now, I want to use that framework to actually
build a nice frontend for the [Digilent Analog
Discovery][1]. 
My friend [Sam Oliver](http://sam-oliver.com/) helped me by building
the frontend part of this using [D3](http://d3js.org/). 

Since Thrift autogenerated all of the code to handle the remote
procedure calls, all I had to do was implement the functionalities
that I provided. One of the annoying aspects was that my C++ server
couldn't initialize any communications, it could only respond to JS
requests, but I was able to work around that without too much of a
hassle. To construct a logical interface I had to truly understand 
how the [Analog Discovery][1] worked.

## [Analog Discovery][1]

*The major source of this information was the [WaveForms SDK
Manual](http://www.digilentinc.com/data/products/waveforms/waveforms_sdk_rm_3.pdf) which discusses the DWF Library*

### Generic Control

The SDK enumerates a generic set of steps to use the API:

1. Discover Devices
2. Open Device using FDwfDeviceOpen
3. Enable Instrument
4. Configure Instrument / (Acquire or Generate) Signals
5. Disable Instrument
6. Close Device using FDwfDeviceClose

There are 4 groups of API functions:

* Device Enumeration
* Device Control
* Instrument Control
* System Information

We'll be focusing on the instrument control.

### Instruments

Instruments in the DWF are controlled using 3 separate functions:

* Reset
 * Resets parameters to default values
* Configure
 * Configure and/or start instrument
* Status
 * Reads information from instrument

These become functions that typically take 4 forms:

* Info
 * Gets info for instrument. ie) min/max, modes, ...
* Set
 * Sets instrument parameter, slightly different behavior with
 **AutoConfigure**
* Get
 * Gets instrument parameter
* Status
 * Returns parameter value

The Analog Discovery has several measurement instruments:

* <a href="#analogin">AnalogIn</a>
* AnalogOut
* AnalogIO
* DigitalIn
* DigitalOut
* DigitalIO

But, we're most concerned with AnalogIn for the time being so we'll
focus on that for now.

#### <div id="analogin">AnalogIn Instrument</div>

Here is a state machine highlighting common usage of the AnalogIn
instrument, which is provided by the SDK manual. 

![AnalogIn State
Machine]({{site.url}}/images/making-oscope-ui/analogin-fsm.png
		"AnalogIn FSM")

These states act as such:

* Ready
 * Reached after `FDwfAnalogInConfigure` or any `FDwfAnalogIn*Set`
 call. `FDwfAnalogInConfigure` reconfigures go straight to Configure
 state???
* Configure
 * Any configurations are performed and auto trigger is reset
* Prefill
 * Captures a certain amount of samples that are desired before
 trigger.
* Armed
 * Waiting for trigger
* Running Modes:
  * Single Acquisition: Captures a single buffer based on trigger and
  trigger position parameter
  * Record: Records for a certain amount of time
  * Scan <a href="#scan-screen">Screen</a> / <a href="#scan-shift">Shift</a>: Stays here until configure or set function
* Done
 * Halt state

Acquisition Modes:

* Single: Single buffer acquistion, can use trigger(default)
* Record: Records for certain time
* <div id="scan-shift">ScanShift:</div>
 * Use FDwfAnalogInStatusSamplesValid to get number of acquired samples,
 When reaching bufferSize, waveform 'picture' is shifted for every
 new sample
 * This means that the oldest value is always at the front of the
 buffer. This is probably more applicable than scan screen for our
 applications. Every time that the JS queries for samples we'll just
 send the most recently updated ScanShift buffer.
* <div id="scan-screen">ScanScreen:</div>
 * Both ScanScreen and ScanShift retreive data as a buffer of data
 entries, but within ScanScreen, those values aren't sorted by
 recency. In ScanScreen the most recently updated value is located at
 the IndexWrite location.

Main Difference between ScanScreen and ScanShift is that one writes a
circular buffer, while the other looks like a shifting FIFO queue
(according to the documentation), but aren't those the same thing???

AnalogIn has the three main functions:

```c
//Reset parameters to default values
FDwfAnalogInReset(HDWF hdwf);

//Configure instrument and/or start/stop acquisitions
FDwfAnalogInConfigure(HDWF hdwf, bool fReconfigure, bool fStart);

//Check acquisition, and read data possibly (not in single acq. mode)
//psts receives the acquisition state
FDwfAnalogInStatus(HDWF hdwf, bool fReadData, DwfState* psts);
```

There are a host of Status*() functions which return information from
the last status call to ensure that information and data arrive
simultaneously. They are:

* SamplesLeft
* SamplesValid (acquired samples)
* IndexWrite (gets buffer write pointer in ScanScreen mode)
* AutoTriggered (check if acquisition was auto triggered)
* Data (copies certain number of samples to provided buffer)
* Sample (gets last ADC sample)
* Record (for Record mode???)
	* available # of samples
 	* lost # of samples (acq faster than cpu read, data samples overwritten)
 	* corrupt # of samples (samples overwritten by acq during prev. read,
		 slightly different because of actually modifying user
		 memory???, happens when record length > buffersize/frequency)
 	* Record provides FDwfAnalogInRecordLength* functions
   		* Set
   		* Get

Configuration comes down to using the other 3 of the 4 function types:
get, set, and info. These are called like this: 
`FDwfAnalogIn<Config>[Info | Set | Get](HDWF, ...)`. These parameters
support all 3 function types:

Min/Max Info

* Frequency
* BufferSize
* TriggerPosition
* TriggerChannel
* TriggerHoldOff (Time to wait befor trigger works)

Min/Max w/ Steps Info

* ChannelRange (coupled to ChannelRangeSteps, get all)
* ChannelOffset
* TriggerAutoTimeout
* TriggerLevel
* TriggerHysteresis (???)
* TriggerLength

Bitfield Info

* AcquisitionMode
* ChannelFilter
* TriggerFilter (Filter at each or average)
* TriggerSource (Edge, Pulse, Transition[uses timeout])
* TriggerType 
* TriggerCondition (rising/positive or falling/negative)
* TriggerLengthCondition (shorter pulse, as time, or when ended)

These only support get and set:

* ChannelEnable (access number of channels with channelCount)

TriggerSource settings:

* None: set TriggerSource to `trigsrcNone`
* Auto: set TriggerSource to `!trigsrcNone` and TriggerAutoTimeout to !0
* Normal: set TriggerSource to `!trigsrcNone` and TriggerAutoTimeout to 0

## C++ Server to communicate between JS GUI and DWF Library

I first tried using ScanShift acquisition mode with the idea of
sending the most recently updated buffer every time a request is made.
This makes it seem like it may be convenient to use a thread to handle the consistent
discovery polling actions, but we'll try it without first. Also, note
that the dwf.h file declares some constants, which causes some nasty
multiple definition errors when compiling, so be careful.

## Throughput Testing`

Enabling quick communication between the JS and C++ over Thrift was
necessary to ensure a good UI on the frontend. Sam did a great job
on the charting side of things and was able to create a chart of 5000
data points in 15 ms, which is about 50X faster than Google Charts,
which probably spends a fair amount of time making server queries and
adding unecessary information. So, I focused on the Thrift
communication to assess the bandwidth. Here is a chart I created from
assessing the latency of several payloads of varying sizes:

_Test Performed Using JSON Protocol and HttpServerTransport_

![Transmission Time of Varied Payloads]({{site.url}}/images/making-oscope-ui/transmission-time-plot.png
		"Transmission Time of Varied Payloads")

The linear fit had parameters:

```
m = 9.277 * 10^-4 ms / Byte
b = 13.325 ms
```

One strange thing I noticed was that at 128989 bytes, the
transactions got ridiculously slow, like 9.155 S. I'm not really sure
why it so precipitously declines at that precise point, but it seems
like it would be interesting to look into. I can only assume that this
could be some sort of paging issue, but that's just a guess.

So, it looks like it would be quite worthwhile to attempt to optimize
my payload size. I will be sending at most 8200 ADC values at a time.
Currently, I am sending double values which are easy to represent our
situation, but are quite inneficient in space, each taking up 8 bytes
as opposed to 2 (the Analog Discovery has a 14-bit ADC). I've also
been sending a 32-bit integer as a timestamp along with the values, so
I think I could take my 12 bytes of representation and use only 2. 

Upon further inspection I noticed that by sending an list of objects
as opposed to a list of values I was incurring a fair amount of
overhead, so I switched to just sending a list of double values.

The question is whether the conversion from double to int16 and back again
will be efficient enough. I am almost certain that it will be. Also,
note that by basically encoding our ADC values, we have decreased the
portability of this data, however since we have closed loop control of
the entire system that seems like a fairly trivial problem. I compared
the difference between sending an array of 16-bit integers and doubles 
and here are the results:

![Comparison Between Double and int16]({{site.url}}/images/making-oscope-ui/transmission-time-comparison-int16-double.png
		"Transmission Time of Varied Data Types")

This seems strange, since the double's time increases about twice as
fast, even though it should be increasing 4 times as fast since
doubles are typically represented as 64 bits, perhaps there is some
compression going on.  

For the max data output of the AnalogIn Signal (8192 points), here are
the median latencies in milliseconds using various datatypes in
testThroughput.

| Data Type 	| Median Time 	|
| :-----------:	| :---------: 	|
| (i32, double)	| 106			|
| double		| 27			|
| i16			| 14		  	|
| i16 w/ conv.	| 17			|

The interesting thing to note here is that the pair of a timestamp
with a double incurs more overhead than that due to just the added i32
timestamp. The conversion back and forth between ADC values incurs a
slight overhead, but definitely seems to be worth it in terms of
performance, almost halving transmission time.

## Boost Threads

In the past I've used
[pthreads](http://www.tutorialspoint.com/cplusplus/cpp_multithreading.htm)
with great success, but since Thrift seems to already use Boost, I
thought now would be as good of a time as any to try out Boost
threads. The idea I have is to use the RPC functions to merely copy
from an array that is populated by a continually running device
thread.

[1]: https://www.digilentinc.com/Products/Detail.cfm?NavPath=2,842,1018&Prod=ANALOG-DISCOVERY
