---
layout: post
title: Making a Digital Oscilloscope UI
---

I previously [setup a way for C / C++ programs to communicate to a JS
client using Thrift]({% post_url 2015-3-2-making-a-simple-ui-for-c-programs %}). Now, I want to use that framework to actually
build a nice frontend for the [Digilent Analog
Discovery][1]. 
My friend [Sam Oliver](http://sam-oliver.com/) helped me by building
the frontend part of this using [D3](http://d3js.org/). 

Since Thrift autogenerated all of the code to handle the remote
procedure calls, all I had to do was implement the functionalities
that I provided. One of the annoying aspects was that my C++ server
couldn't initialize any communications, it could only respond to JS
requests, but I was able to work around that without too much of a
hassle. To construct a logical interface I had to truly understand 
how the [Analog Discovery][1] worked.

## [Analog Discovery][1]

*The major source of this information was the [WaveForms SDK
Manual](http://www.digilentinc.com/data/products/waveforms/waveforms_sdk_rm_3.pdf) which discusses the DWF Library*

### Generic Control

The SDK enumerates a generic set of steps to use the API:

1. Discover Devices
2. Open Device using FDwfDeviceOpen
3. Enable Instrument
4. Configure Instrument / (Acquire or Generate) Signals
5. Disable Instrument
6. Close Device using FDwfDeviceClose

There are 4 groups of API functions:

* Device Enumeration
* Device Control
* Instrument Control
* System Information

We'll be focusing on the instrument control.

### Instruments

Instruments in the DWF are controlled using 3 separate functions:

* Reset
 * Resets parameters to default values
* Configure
 * Configure and/or start instrument
* Status
 * Reads information from instrument

These become functions that typically take 4 forms:

* Info
 * Gets info for instrument. ie) min/max, modes, ...
* Set
 * Sets instrument parameter, slightly different behavior with
 **AutoConfigure**
* Get
 * Gets instrument parameter
* Status
 * Returns parameter value

The Analog Discovery has several measurement instruments:

* <a href="#analogin">AnalogIn</a>
* AnalogOut
* AnalogIO
* DigitalIn
* DigitalOut
* DigitalIO

But, we're most concerned with AnalogIn for the time being so we'll
focus on that for now.

#### <div id="analogin">AnalogIn Instrument</div>

Here is a state machine highlighting common usage of the AnalogIn
instrument, which is provided by the SDK manual. 

![AnalogIn State
Machine]({{site.url}}/images/making-oscope-ui/analogin-fsm.png
		"AnalogIn FSM")

These states act as such:

* Ready
 * Reached after `FDwfAnalogInConfigure` or any `FDwfAnalogIn*Set`
 call. `FDwfAnalogInConfigure` reconfigures go straight to Configure
 state???
* Configure
 * Any configurations are performed and auto trigger is reset
* Prefill
 * Captures a certain amount of samples that are desired before
 trigger.
* Armed
 * Waiting for trigger
* Running Modes:
  * Single Acquisition: Captures a single buffer based on trigger and
  trigger position parameter
  * Record: Records for a certain amount of time
  * Scan <a href="#scan-screen">Screen</a> / <a href="#scan-shift">Shift</a>: Stays here until configure or set function
* Done
 * Halt state

Acquisition Modes:

* Single: Single buffer acquistion, can use trigger(default)
* Record: Records for certain time
* <div id="scan-shift">ScanShift:</div>
 * Ignores trigger
 * Acquires in FIFO style
 * Use FDwfAnalogInStatusSamplesValid to get number of acquired
 samples
 * When reaching bufferSize, waveform 'picture' is shifted for every
 new sample
* <div id="scan-screen">ScanScreen:</div>
 * Ignores the trigger
 * IndexWrite shows buffer write position
 * Think heart monitor display

Main Difference between ScanScreen and ScanShift is that one writes a
circular buffer, while the other looks like a shifting FIFO queue
(according to the documentation), but aren't those the same thing???

AnalogIn has the three main functions:

```c
//Reset parameters to default values
FDwfAnalogInReset(HDWF hdwf);

//Configure instrument and/or start/stop acquisitions
FDwfAnalogInConfigure(HDWF hdwf, bool fReconfigure, bool fStart);

//Check acquisition, and read data possibly (not in single acq. mode)
//psts receives the acquisition state
FDwfAnalogInStatus(HDWF hdwf, bool fReadData, DwfState* psts);
```

There are a host of Status*() functions which return information from
the last status call to ensure that information and data arrive
simultaneously. They are:

* SamplesLeft
* SamplesValid (acquired samples)
* IndexWrite (gets buffer write pointer in ScanScreen mode)
* AutoTriggered (check if acquisition was auto triggered)
* Data (copies certain number of samples to provided buffer)
* Sample (gets last ADC sample)
* Record (for Record mode???)
	* available # of samples
 	* lost # of samples (acq faster than cpu read, data samples overwritten)
 	* corrupt # of samples (samples overwritten by acq during prev. read,
		 slightly different because of actually modifying user
		 memory???, happens when record length > buffersize/frequency)
 	* Record provides FDwfAnalogInRecordLength* functions
   		* Set
   		* Get

Configuration comes down to using the other 3 of the 4 function types:
get, set, and info. These are called like this: 
`FDwfAnalogIn<Config>[Info | Set | Get](HDWF, ...)`. These parameters
support all 3 function types:

Min/Max Info

* Frequency
* BufferSize
* TriggerPosition
* TriggerChannel
* TriggerHoldOff (Time to wait befor trigger works)

Min/Max w/ Steps Info

* ChannelRange (coupled to ChannelRangeSteps, get all)
* ChannelOffset
* TriggerAutoTimeout
* TriggerLevel
* TriggerHysteresis (???)
* TriggerLength

Bitfield Info

* AcquisitionMode
* ChannelFilter
* TriggerFilter (Filter at each or average)
* TriggerSource (Edge, Pulse, Transition[uses timeout])
* TriggerType 
* TriggerCondition (rising/positive or falling/negative)
* TriggerLengthCondition (shorter pulse, as time, or when ended)

These only support get and set:

* ChannelEnable (access number of channels with channelCount)

TriggerSource settings:

* None: set TriggerSource to `trigsrcNone`
* Auto: set TriggerSource to `!trigsrcNone` and TriggerAutoTimeout to !0
* Normal: set TriggerSource to `!trigsrcNone` and TriggerAutoTimeout to 0





[1]: https://www.digilentinc.com/Products/Detail.cfm?NavPath=2,842,1018&Prod=ANALOG-DISCOVERY
